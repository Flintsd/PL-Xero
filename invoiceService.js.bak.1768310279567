// invoiceService.js

const { xero, ensureXeroReady } = require("./xeroClient");
const { buildLineItems } = require("./invoiceHelpers");

class AppError extends Error {
  constructor(message, { status = 500, code = "INTERNAL_ERROR", details } = {}) {
    super(message);
    this.name = "AppError";
    this.status = status;
    this.code = code;
    if (details !== undefined) {
      this.details = details;
    }
  }
}

function isNonEmptyObject(value) {
  return (
    value &&
    typeof value === "object" &&
    !Array.isArray(value) &&
    Object.keys(value).length > 0
  );
}

function validatePayload(plPayload) {
  const isObject =
    plPayload && typeof plPayload === "object" && !Array.isArray(plPayload);

  if (!isObject) {
    throw new AppError("Invalid payload: expected object", {
      status: 400,
      code: "BAD_REQUEST",
    });
  }

  if (Object.keys(plPayload).length === 0) {
    throw new AppError("Invalid payload: empty object", {
      status: 400,
      code: "BAD_REQUEST",
    });
  }

  const orderItems = plPayload?.order_detail?.items;
  const lineItems = plPayload?.lineItems;
  const hasOrderItems = isNonEmptyObject(orderItems);
  const hasLineItems = Array.isArray(lineItems) && lineItems.length > 0;

  if (!hasOrderItems && !hasLineItems) {
    throw new AppError("Invalid payload: missing invoice lines", {
      status: 400,
      code: "BAD_REQUEST",
    });
  }
}

function toBool(val) {
  if (typeof val === "boolean") return val;
  if (val == null) return false;
  const s = String(val).trim().toLowerCase();
  return s === "true" || s === "1" || s === "yes";
}

/**
 * Derive all the “context” we need for the invoice
 * from the incoming Power Automate / PrintLogic payload.
 */
function deriveContext(payload) {
  const {
    template,
    logicSource,
    order_po,
    pl_order = {},
    markAsPaid,
    emailCustomer,
  } = payload;

  const isWebOrder = !!(order_po && order_po.startsWith("WEB-"));

  // Brand / template → branding theme
  let brandingThemeId = undefined;
  let customerCategory = pl_order.customer_category || "";
  let brandTrackingOption = undefined;

 const tplRaw = template || customerCategory || "";
const tpl = String(tplRaw).trim();
const tplKey = tpl.toLowerCase();

const BRANDING_BY_TPL = {
  // Edinburgh
  "edinburgh_banners": process.env.XERO_BRAND_EDINBURGH,
  "edinburgh banners": process.env.XERO_BRAND_EDINBURGH,

  // SDK
  "sdk": process.env.XERO_BRAND_SDK,
  "sdk_group": process.env.XERO_BRAND_SDK,
  "sdk group": process.env.XERO_BRAND_SDK,

  // Giclee
  "giclee": process.env.XERO_BRAND_GICLEE,
  "giclée": process.env.XERO_BRAND_GICLEE,

  // PPS
  "pps": process.env.XERO_BRAND_PPS,
};

brandingThemeId = BRANDING_BY_TPL[tplKey] || undefined;

// tracking/category defaults
customerCategory = customerCategory || tpl || "Default";
brandTrackingOption = tpl || "Default";

// Optional: force “nice” tracking labels
if (tplKey === "edinburgh_banners" || tplKey === "edinburgh banners") {
  customerCategory = "Edinburgh_Banners";
  brandTrackingOption = "Edinburgh Banners";
} else if (tplKey === "giclee" || tplKey === "giclée") {
  customerCategory = "Giclee";
  brandTrackingOption = "Giclee";
}


  const markAsPaidFlag = toBool(markAsPaid);
  const emailCustomerFlag = toBool(emailCustomer);

  const XERO_STRIPE_ACCOUNT =
    process.env.XERO_STRIPE_ACCOUNT ||
    process.env.XERO_STRIPE_ACCOUNT_CODE ||
    "0002";

  const context = {
    template: tpl,
    logicSource: logicSource || "",
    isWebOrder,
    customerCategory,
    brandingThemeId,
    brandTrackingOption,
    markAsPaidFlag,
    emailCustomerFlag,
    XERO_STRIPE_ACCOUNT,
  };

  console.log("[invoiceService] derived values:", JSON.stringify(context, null, 2));

  // safe fingerprint (no full IDs in logs)
  const _bt = (context.brandingThemeId || "").trim();
  console.log("[invoiceService] brandingThemeId fp:", _bt ? ("len=" + _bt.length + " " + _bt.slice(0,4) + "…" + _bt.slice(-4)) : "(none)");

  return context;
}

/**
 * Build the Xero Invoice object from the incoming payload
 * and derived context.
 */
function buildInvoiceModel(payload, context) {
  const { order_number, order_po, pl_order = {}, order_detail = {} } = payload;
  const { brandingThemeId, brandTrackingOption } = context;

  const todayIso = new Date().toISOString().slice(0, 10);

  const contactName =
    pl_order.customer_name ||
    order_detail.customer_name ||
    pl_order.order_contact ||
    order_detail.order_contact ||
    "Unknown Customer";

  const contactEmail =
    pl_order.customer_email ||
    pl_order.order_contact_email ||
    order_detail.order_contact_email ||
    order_detail.customer_email ||
    undefined;

  const dueDate =
    order_detail.order_date_due && order_detail.order_date_due !== "0000-00-00"
      ? order_detail.order_date_due
      : todayIso;

  const referenceParts = [];
  if (order_po) referenceParts.push(order_po);
  if (order_number) referenceParts.push(`[${order_number}]`);
  const reference = referenceParts.join(" ");

  // Build line items from the full PL payload so invoiceHelpers
  // can find order_detail.items itself
  const lineItems = buildLineItems(payload, brandTrackingOption);
  console.log("[invoiceService] lineItems length:", lineItems.length);

  const invoice = {
    type: "ACCREC",
    contact: {
      name: contactName,
    },
    lineItems,
    date: todayIso,
    dueDate,
    reference,
    status: "AUTHORISED",
    lineAmountTypes: "Exclusive",
  };

  if (contactEmail) {
    invoice.contact.emailAddress = contactEmail;
  }

  if (brandingThemeId) {
    invoice.brandingThemeID = brandingThemeId;
  }

  console.log(
    "[invoiceService] Xero invoice model:",
    JSON.stringify(invoice, null, 2)
  );

  return invoice;
}

/**
 * Optionally mark the invoice as paid in Xero using createPayments.
 */
async function maybeMarkAsPaid(
  xeroClient,
  xeroTenantId,
  payload,
  context,
  createdInvoice
) {
  if (!context.markAsPaidFlag) {
    return;
  }

  if (!createdInvoice || !createdInvoice.invoiceID) {
    console.warn(
      "[invoiceService] markAsPaid requested but no invoiceID returned from Xero"
    );
    return;
  }

  const { pl_order = {}, order_detail = {} } = payload;

  const totalIncVatStr =
    pl_order.order_tot_incvat ||
    (pl_order.order_total && pl_order.order_vat
      ? (
          parseFloat(pl_order.order_total || "0") +
          parseFloat(pl_order.order_vat || "0")
        ).toFixed(2)
      : null) ||
    (order_detail.order_total && order_detail.order_vat
      ? (
          parseFloat(order_detail.order_total || "0") +
          parseFloat(order_detail.order_vat || "0")
        ).toFixed(2)
      : null);

  const amount = totalIncVatStr ? parseFloat(totalIncVatStr) : null;

  if (!amount || isNaN(amount)) {
    console.warn(
      "[invoiceService] markAsPaid requested but could not determine amount, skipping payment."
    );
    return;
  }

  const todayIso = new Date().toISOString().slice(0, 10);

  const payment = {
    payments: [
      {
        invoice: {
          invoiceID: createdInvoice.invoiceID,
        },
        account: {
          code: context.XERO_STRIPE_ACCOUNT,
        },
        date: todayIso,
        amount,
      },
    ],
  };

  console.log(
    "[invoiceService] Creating payment to mark invoice as paid:",
    JSON.stringify(payment, null, 2)
  );

  try {
    const response = await xeroClient.accountingApi.createPayments(
      xeroTenantId,
      payment,
      true // summarizeErrors
    );
    console.log(
      "[invoiceService] createPayments response:",
      JSON.stringify(response.body || response.response?.statusCode, null, 2)
    );
  } catch (err) {
    const errorJson = err?.response?.body
      ? JSON.stringify(err.response.body, null, 2)
      : err.message;
    console.error("[invoiceService] Error creating payment:", errorJson);
  }
}

/**
 * Optionally email the invoice to the customer.
 */
async function maybeEmailInvoice(
  xeroClient,
  xeroTenantId,
  context,
  createdInvoice
) {
  if (!context.emailCustomerFlag) return;
  if (!createdInvoice || !createdInvoice.invoiceID) {
    console.warn(
      "[invoiceService] emailCustomer requested but no invoiceID returned from Xero"
    );
    return;
  }

  console.log(
    `[invoiceService] Emailing invoice ${createdInvoice.invoiceID} to customer`
  );

  try {
    // emailInvoice expects an empty object as body
    const requestEmpty = {};
    const response = await xeroClient.accountingApi.emailInvoice(
      xeroTenantId,
      createdInvoice.invoiceID,
      requestEmpty
    );
    console.log(
      "[invoiceService] emailInvoice response:",
      JSON.stringify(response.body || response.response?.statusCode, null, 2)
    );
  } catch (err) {
    const errorJson = err?.response?.body
      ? JSON.stringify(err.response.body, null, 2)
      : err.message;
    console.error("[invoiceService] Error emailing invoice:", errorJson);
  }
}

/**
 * Main entry point called from xero-bridge.js
 * with the body from Power Automate / PrintLogic.
 */
async function createInvoiceFromPlPayload(plPayload) {
  console.log(
    "[invoiceService.createInvoiceFromPlPayload] - incoming payload:\n",
    JSON.stringify(plPayload, null, 2)
  );

  validatePayload(plPayload);

  const context = deriveContext(plPayload);

  const invoice = buildInvoiceModel(plPayload, context);

  // Structure the payload the Xero SDK expects:
  // { invoices: [ invoice ] }
  const invoicesWrapper = { invoices: [invoice] };

  const xeroTenantId = await ensureXeroReady();

  console.log("[invoiceService] Calling createInvoices with payload:");
  console.log(JSON.stringify(invoicesWrapper, null, 2));

  let result;
  try {
    const summarizeErrors = true;
    const unitdp = 2;

    result = await xero.accountingApi.createInvoices(
      xeroTenantId,
      invoicesWrapper,
      summarizeErrors,
      unitdp
    );
  } catch (err) {
    const unwrap = (v) =>
      v && typeof v === "object"
        ? v.error ?? v.innerError ?? v.cause ?? v
        : v;
    const raw = unwrap(err);
    let eObj = raw;
    if (typeof raw === "string") {
      try {
        eObj = JSON.parse(raw);
      } catch {
        eObj = { message: raw };
      }
    } else if (raw == null) {
      eObj = { message: "Unknown error from Xero client" };
    }

    const status =
      eObj?.response?.statusCode ??
      eObj?.response?.status ??
      eObj?.status ??
      eObj?.statusCode ??
      eObj?.StatusCode ??
      null;

    const body =
      eObj?.response?.body ??
      eObj?.response?.data ??
      eObj?.body ??
      eObj?.data ??
      eObj?.error ??
      eObj?.Error ??
      null;

    const details =
      body ?? {
        thrownType: typeof raw,
        status,
        message: eObj?.message ?? null,
        keys: eObj && typeof eObj === "object" ? Object.keys(eObj) : null,
        rawPrefix: typeof raw === "string" ? raw.slice(0, 400) : null,
      };

    console.error("[invoiceService] createInvoices threw:", {
      thrownType: typeof raw,
      status,
      message: eObj?.message ?? null,
      rawPrefix: typeof raw === "string" ? raw.slice(0, 200) : null,
    });

    if (status === 400) {
      throw new AppError("Xero validation error", {
        status: 400,
        code: "XERO_VALIDATION",
        details,
      });
    }

    if (status === 401 || status === 403) {
      throw new AppError("Xero auth error", {
        status: 502,
        code: "XERO_AUTH",
        details,
      });
    }

    throw new AppError("Xero upstream error", {
      status: 502,
      code: "XERO_UPSTREAM",
      details,
    });
  }

  const createdInvoice =
    result?.body?.invoices && result.body.invoices.length
      ? result.body.invoices[0]
      : null;

  console.log(
    "[invoiceService] createInvoices response:",
    JSON.stringify(result.body || result.response?.statusCode, null, 2)
  );

  if (!createdInvoice?.invoiceID) {
    throw new AppError("Xero response missing invoiceID", {
      status: 502,
      code: "XERO_BAD_RESPONSE",
      details: result.body || null,
    });
  }

  // Mark as paid, if requested
  await maybeMarkAsPaid(xero, xeroTenantId, plPayload, context, createdInvoice);

  // Email customer, if requested
  await maybeEmailInvoice(xero, xeroTenantId, context, createdInvoice);

  const invoiceId = createdInvoice.invoiceID || createdInvoice.InvoiceID;
  const invoiceNumber =
    createdInvoice.invoiceNumber || createdInvoice.InvoiceNumber || null;
  const reference =
    createdInvoice.reference ||
    createdInvoice.Reference ||
    invoice.reference ||
    null;

  return {
    invoiceId,
    invoiceNumber,
    reference,
    invoice: createdInvoice,
    rawResponse: result.body || null,
  };
}

module.exports = {
  AppError,
  createInvoiceFromPlPayload,
};
